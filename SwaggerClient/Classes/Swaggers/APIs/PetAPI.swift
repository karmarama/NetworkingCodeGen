//
// PetAPI.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation
import Networking
import Combine

class PetAPIRepositoryFake: PetAPIRepository { 

    var addPetError: Error? = nil
    var addPetResponse: Networking.Empty = .fake()

    func addPet(body: Pet) -> Future<Networking.Empty, Error> {
        return Future<Networking.Empty, Error> { promise in 
            if let error = self.addPetError { 
                promise(.failure(error))
            } else {
                promise(.success(self.addPetResponse))
            }
        }
    }

    var deletePetError: Error? = nil
    var deletePetResponse: Networking.Empty = .fake()

    func deletePet(petId: Int64, apiKey: String?) -> Future<Networking.Empty, Error> {
        return Future<Networking.Empty, Error> { promise in 
            if let error = self.deletePetError { 
                promise(.failure(error))
            } else {
                promise(.success(self.deletePetResponse))
            }
        }
    }

    var findPetsByStatusError: Error? = nil
    var findPetsByStatusResponse: [Pet] = .fake()

    func findPetsByStatus(status: [String]) -> Future<[Pet], Error> {
        return Future<[Pet], Error> { promise in 
            if let error = self.findPetsByStatusError { 
                promise(.failure(error))
            } else {
                promise(.success(self.findPetsByStatusResponse))
            }
        }
    }

    var findPetsByTagsError: Error? = nil
    var findPetsByTagsResponse: [Pet] = .fake()

    func findPetsByTags(tags: [String]) -> Future<[Pet], Error> {
        return Future<[Pet], Error> { promise in 
            if let error = self.findPetsByTagsError { 
                promise(.failure(error))
            } else {
                promise(.success(self.findPetsByTagsResponse))
            }
        }
    }

    var getPetByIdError: Error? = nil
    var getPetByIdResponse: Pet = .fake()

    func getPetById(petId: Int64) -> Future<Pet, Error> {
        return Future<Pet, Error> { promise in 
            if let error = self.getPetByIdError { 
                promise(.failure(error))
            } else {
                promise(.success(self.getPetByIdResponse))
            }
        }
    }

    var updatePetError: Error? = nil
    var updatePetResponse: Networking.Empty = .fake()

    func updatePet(body: Pet) -> Future<Networking.Empty, Error> {
        return Future<Networking.Empty, Error> { promise in 
            if let error = self.updatePetError { 
                promise(.failure(error))
            } else {
                promise(.success(self.updatePetResponse))
            }
        }
    }

    var updatePetWithFormError: Error? = nil
    var updatePetWithFormResponse: Networking.Empty = .fake()

    func updatePetWithForm(petId: Int64, name: String?, status: String?) -> Future<Networking.Empty, Error> {
        return Future<Networking.Empty, Error> { promise in 
            if let error = self.updatePetWithFormError { 
                promise(.failure(error))
            } else {
                promise(.success(self.updatePetWithFormResponse))
            }
        }
    }

    var uploadFileError: Error? = nil
    var uploadFileResponse: ApiResponse = .fake()

    func uploadFile(petId: Int64, additionalMetadata: String?, file: Data?) -> Future<ApiResponse, Error> {
        return Future<ApiResponse, Error> { promise in 
            if let error = self.uploadFileError { 
                promise(.failure(error))
            } else {
                promise(.success(self.uploadFileResponse))
            }
        }
    }
}


protocol PetAPIRepository { 
    func addPet(body: Pet) -> Future<Networking.Empty, Error>
    func deletePet(petId: Int64, apiKey: String?) -> Future<Networking.Empty, Error>
    func findPetsByStatus(status: [String]) -> Future<[Pet], Error>
    func findPetsByTags(tags: [String]) -> Future<[Pet], Error>
    func getPetById(petId: Int64) -> Future<Pet, Error>
    func updatePet(body: Pet) -> Future<Networking.Empty, Error>
    func updatePetWithForm(petId: Int64, name: String?, status: String?) -> Future<Networking.Empty, Error>
    func uploadFile(petId: Int64, additionalMetadata: String?, file: Data?) -> Future<ApiResponse, Error>
}

extension Repository: PetAPIRepository {
    func addPet(body: Pet) -> Future<Networking.Empty, Error> {
        let resource = PetAPI.addPetResource(body: body) 
        return webservice.future(for: resource)
    }
    
    func deletePet(petId: Int64, apiKey: String? = nil) -> Future<Networking.Empty, Error> {
        let resource = PetAPI.deletePetResource(petId: petId,apiKey: apiKey) 
        return webservice.future(for: resource)
    }
    
    func findPetsByStatus(status: [String]) -> Future<[Pet], Error> {
        let resource = PetAPI.findPetsByStatusResource(status: status) 
        return webservice.future(for: resource)
    }
    
    func findPetsByTags(tags: [String]) -> Future<[Pet], Error> {
        let resource = PetAPI.findPetsByTagsResource(tags: tags) 
        return webservice.future(for: resource)
    }
    
    func getPetById(petId: Int64) -> Future<Pet, Error> {
        let resource = PetAPI.getPetByIdResource(petId: petId) 
        return webservice.future(for: resource)
    }
    
    func updatePet(body: Pet) -> Future<Networking.Empty, Error> {
        let resource = PetAPI.updatePetResource(body: body) 
        return webservice.future(for: resource)
    }
    
    func updatePetWithForm(petId: Int64, name: String? = nil, status: String? = nil) -> Future<Networking.Empty, Error> {
        let resource = PetAPI.updatePetWithFormResource(petId: petId,name: name,status: status) 
        return webservice.future(for: resource)
    }
    
    func uploadFile(petId: Int64, additionalMetadata: String? = nil, file: Data? = nil) -> Future<ApiResponse, Error> {
        let resource = PetAPI.uploadFileResource(petId: petId,additionalMetadata: additionalMetadata,file: file) 
        return webservice.future(for: resource)
    }
    
}


open class PetAPI {

    /**
     Add a new pet to the store
     - POST /pet
     - OAuth:
       - type: oauth2
       - name: petstore_auth
     - parameter body: (body) Pet object that needs to be added to the store 

     - returns: Resource<Pet,Networking.Empty> 
     */
    open class func addPetResource(body: Pet) -> Resource<Pet,Networking.Empty> {
        let path = "/pet"
        
        return Resource(endpoint: path, 
                queryParameters: [],
                method: HTTP.Method(string: "POST"), 
                body: HTTP.Body(data: body, contentType: JSONContentType()),
                decoder: JSONDecoder()) 
          
    }


    /**
     Deletes a pet
     - DELETE /pet/{petId}
     - OAuth:
       - type: oauth2
       - name: petstore_auth
     - parameter petId: (path) Pet id to delete      - parameter apiKey: (header)  (optional)

     - returns: Resource<Networking.Empty,Networking.Empty> 
     */
    open class func deletePetResource(petId: Int64, apiKey: String? = nil) -> Resource<Networking.Empty,Networking.Empty> {
        var path = "/pet/{petId}"
        let petIdPreEscape = "\(petId)"
        let petIdPostEscape = petIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{petId}", with: petIdPostEscape, options: .literal, range: nil)
        
        return Resource(endpoint: path, 
                queryParameters: [],
                method: HTTP.Method(string: "DELETE"), 
                body: nil,
                decoder: JSONDecoder()) 
          
    }

    /**
     * enum for parameter status
     */
    public enum Status_findPetsByStatus: String { 
        case available = "available"
        case pending = "pending"
        case sold = "sold"
    }


    /**
     Finds Pets by status
     - GET /pet/findByStatus
     - Multiple status values can be provided with comma separated strings
     - OAuth:
       - type: oauth2
       - name: petstore_auth
     - examples: [{contentType=application/json, example=[ {
  "photoUrls" : [ "photoUrls", "photoUrls" ],
  "name" : "doggie",
  "id" : 0,
  "category" : {
    "name" : "name",
    "id" : 6
  },
  "tags" : [ {
    "name" : "name",
    "id" : 1
  }, {
    "name" : "name",
    "id" : 1
  } ],
  "status" : "available"
}, {
  "photoUrls" : [ "photoUrls", "photoUrls" ],
  "name" : "doggie",
  "id" : 0,
  "category" : {
    "name" : "name",
    "id" : 6
  },
  "tags" : [ {
    "name" : "name",
    "id" : 1
  }, {
    "name" : "name",
    "id" : 1
  } ],
  "status" : "available"
} ]}]
     - parameter status: (query) Status values that need to be considered for filter 

     - returns: Resource<Networking.Empty,[Pet]> 
     */
    open class func findPetsByStatusResource(status: [String]) -> Resource<Networking.Empty,[Pet]> {
        let path = "/pet/findByStatus"
        
        return Resource(endpoint: path, 
                queryParameters: 
        APIHelper.mapValuesToQueryItems([
                        "status": status
        ]),
                method: HTTP.Method(string: "GET"), 
                body: nil,
                decoder: JSONDecoder()) 
          
    }


    /**
     Finds Pets by tags
     - GET /pet/findByTags
     - Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     - OAuth:
       - type: oauth2
       - name: petstore_auth
     - examples: [{contentType=application/json, example=[ {
  "photoUrls" : [ "photoUrls", "photoUrls" ],
  "name" : "doggie",
  "id" : 0,
  "category" : {
    "name" : "name",
    "id" : 6
  },
  "tags" : [ {
    "name" : "name",
    "id" : 1
  }, {
    "name" : "name",
    "id" : 1
  } ],
  "status" : "available"
}, {
  "photoUrls" : [ "photoUrls", "photoUrls" ],
  "name" : "doggie",
  "id" : 0,
  "category" : {
    "name" : "name",
    "id" : 6
  },
  "tags" : [ {
    "name" : "name",
    "id" : 1
  }, {
    "name" : "name",
    "id" : 1
  } ],
  "status" : "available"
} ]}]
     - parameter tags: (query) Tags to filter by 

     - returns: Resource<Networking.Empty,[Pet]> 
     */
    open class func findPetsByTagsResource(tags: [String]) -> Resource<Networking.Empty,[Pet]> {
        let path = "/pet/findByTags"
        
        return Resource(endpoint: path, 
                queryParameters: 
        APIHelper.mapValuesToQueryItems([
                        "tags": tags
        ]),
                method: HTTP.Method(string: "GET"), 
                body: nil,
                decoder: JSONDecoder()) 
          
    }


    /**
     Find pet by ID
     - GET /pet/{petId}
     - Returns a single pet
     - API Key:
       - type: apiKey api_key 
       - name: api_key
     - examples: [{contentType=application/json, example={
  "photoUrls" : [ "photoUrls", "photoUrls" ],
  "name" : "doggie",
  "id" : 0,
  "category" : {
    "name" : "name",
    "id" : 6
  },
  "tags" : [ {
    "name" : "name",
    "id" : 1
  }, {
    "name" : "name",
    "id" : 1
  } ],
  "status" : "available"
}}]
     - parameter petId: (path) ID of pet to return 

     - returns: Resource<Networking.Empty,Pet> 
     */
    open class func getPetByIdResource(petId: Int64) -> Resource<Networking.Empty,Pet> {
        var path = "/pet/{petId}"
        let petIdPreEscape = "\(petId)"
        let petIdPostEscape = petIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{petId}", with: petIdPostEscape, options: .literal, range: nil)
        
        return Resource(endpoint: path, 
                queryParameters: [],
                method: HTTP.Method(string: "GET"), 
                body: nil,
                decoder: JSONDecoder()) 
          
    }


    /**
     Update an existing pet
     - PUT /pet
     - OAuth:
       - type: oauth2
       - name: petstore_auth
     - parameter body: (body) Pet object that needs to be added to the store 

     - returns: Resource<Pet,Networking.Empty> 
     */
    open class func updatePetResource(body: Pet) -> Resource<Pet,Networking.Empty> {
        let path = "/pet"
        
        return Resource(endpoint: path, 
                queryParameters: [],
                method: HTTP.Method(string: "PUT"), 
                body: HTTP.Body(data: body, contentType: JSONContentType()),
                decoder: JSONDecoder()) 
          
    }


    /**
     Updates a pet in the store with form data
     - POST /pet/{petId}
     - OAuth:
       - type: oauth2
       - name: petstore_auth
     - parameter petId: (path) ID of pet that needs to be updated      - parameter name: (form)  (optional)     - parameter status: (form)  (optional)

     - returns: Resource<Networking.Empty,Networking.Empty> 
     */
    open class func updatePetWithFormResource(petId: Int64, name: String? = nil, status: String? = nil) -> Resource<Networking.Empty,Networking.Empty> {
        var path = "/pet/{petId}"
        let petIdPreEscape = "\(petId)"
        let petIdPostEscape = petIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{petId}", with: petIdPostEscape, options: .literal, range: nil)
        
        return Resource(endpoint: path, 
                queryParameters: [],
                method: HTTP.Method(string: "POST"), 
                body: nil,
                decoder: JSONDecoder()) 
          
    }


    /**
     uploads an image
     - POST /pet/{petId}/uploadImage
     - OAuth:
       - type: oauth2
       - name: petstore_auth
     - examples: [{contentType=application/json, example={
  "code" : 0,
  "type" : "type",
  "message" : "message"
}}]
     - parameter petId: (path) ID of pet to update      - parameter additionalMetadata: (form)  (optional)     - parameter file: (form)  (optional)

     - returns: Resource<Networking.Empty,ApiResponse> 
     */
    open class func uploadFileResource(petId: Int64, additionalMetadata: String? = nil, file: Data? = nil) -> Resource<Networking.Empty,ApiResponse> {
        var path = "/pet/{petId}/uploadImage"
        let petIdPreEscape = "\(petId)"
        let petIdPostEscape = petIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{petId}", with: petIdPostEscape, options: .literal, range: nil)
        
        return Resource(endpoint: path, 
                queryParameters: [],
                method: HTTP.Method(string: "POST"), 
                body: nil,
                decoder: JSONDecoder()) 
          
    }

}
